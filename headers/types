#ifndef TYPES_H
#define TYPES_H

#include <cuda_fp16.h>

using float16 = half;
using float32 = float;
using float64 = double;

using FloatT = float32;

using uint32 = unsigned int;
using int32 = int;
using int16 = short;
using int8 = char;

using uint64 = unsigned long long;
using int64 = long long;
using uint16 = unsigned short;
using uint8 = unsigned char;

static_assert(sizeof(uint32) == 4, "Not 4 bytes");
static_assert(sizeof(uint64) == 8, "Not 8 bytes");
static_assert(sizeof(int32) == 4, "Not 4 bytes");
static_assert(sizeof(int64) == 8, "Not 8 bytes");
static_assert(sizeof(float32) == 4, "Not 4 bytes");
static_assert(sizeof(float64) == 8, "Not 8 bytes");
static_assert(sizeof(float16) == 2, "Not 2 bytes");
static_assert(sizeof(int8) == 1, "Not 1 byte");
static_assert(sizeof(int16) == 2, "Not 2 bytes");
static_assert(sizeof(uint8) == 1, "Not 1 byte");
static_assert(sizeof(uint16) == 2, "Not 2 bytes");


inline bool is_little_endian()
{
    int num = 1;
    char *ptr = reinterpret_cast<char*>(&num);
    return *ptr == 1;
}

template <typename T>
inline uint32 get_type_identifier()
{
    uint32 endiannes = is_little_endian() ? 0xAA : 0xBB;
    endiannes <<= 16;

    // float types begin with 0xF
    if constexpr (std::is_same<T, float16>::value) return 0xF1 | endiannes;
    if constexpr (std::is_same<T, float32>::value) return 0xF2 | endiannes;
    if constexpr (std::is_same<T, float64>::value) return 0xF3 | endiannes;

    // int types begin with 0x1
    if constexpr (std::is_same<T, int8>::value) return 0x11 | endiannes;
    if constexpr (std::is_same<T, int16>::value) return 0x12 | endiannes;
    if constexpr (std::is_same<T, int32>::value) return 0x13 | endiannes;
    if constexpr (std::is_same<T, int64>::value) return 0x14 | endiannes;

    // uint types begin with 0x2
    if constexpr (std::is_same<T, uint8>::value) return 0x21 | endiannes;
    if constexpr (std::is_same<T, uint16>::value) return 0x22 | endiannes;
    if constexpr (std::is_same<T, uint32>::value) return 0x23 | endiannes;
    if constexpr (std::is_same<T, uint64>::value) return 0x24 | endiannes;

    return 0x0;
}

template <class T, class Enable = void>
struct is_floating_point
{
    static const bool value = false;
};

template <class T>
struct is_floating_point<T, typename std::enable_if<std::is_floating_point<T>::value ||
                                                    std::is_same<T, float16>::value>::type>
{
    static const bool value = true;
    using type = T;
};

template <typename T>
struct Fp32Accum : std::enable_if<(sizeof(T) <= 4 && is_floating_point<T>::value), float32>
{
};

template <typename T>
struct Uint32Accum : std::enable_if<(sizeof(T) <= 4 && std::is_unsigned<T>::value), uint32>
{
};

template <typename T>
struct Fp64AccumT : std::enable_if<(sizeof(T) <= 8 && is_floating_point<T>::value), float64>
{
};

template <typename T>
struct Uint64Accum : std::enable_if<sizeof(T) <= 8 && std::is_unsigned<T>::value, uint64>
{
};

template <typename T>
using Accum32T =
    typename std::conditional<is_floating_point<T>::value, Fp32Accum<T>, Uint32Accum<T>>::type;

template <typename T>
using Accum64T =
    typename std::conditional<is_floating_point<T>::value, Fp64AccumT<T>, Uint64Accum<T>>::type;

template <typename T>
using AccumT = typename std::conditional<sizeof(T) <= 4, Accum32T<T>, Accum64T<T>>::type;

#endif  // TYPES_H